"use strict";

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var WORST = 0.1;
var HARD = 0.2;
var CORRECT = 0.5;
var BEST = 1;

var limitNumber = function limitNumber(number, min, max) {
  var ret = number;
  if (number < min) {
    ret = min;
  } else if (number > max) {
    ret = max;
  }
  return ret;
};

// Value between 1 and 2
var getPercentOverdue = function getPercentOverdue(word, today) {
  var calculated = limitNumber((today - word.update) / word.interval, 1);
  return calculated > 2 ? 2 : calculated;
};

var getRandomFloat = function getRandomFloat(min, max) {
  return Math.random() * (max - min) + min;
};

var calculate = function calculate(word, performanceRating, today, scale) {

  var percentOverDue = 1;//getPercentOverdue(word, today);

  //Value between 0 (Easy) and 1 (Difficult)

  var difficulty = limitNumber(word.difficulty + (3 - 9 * performanceRating) * percentOverDue /  (17 + performanceRating * 40), 0, 1);
  var difficultyWeight = 3  * (scale + performanceRating) - 1.7 * difficulty
  var interval;
//console.log(difficultyWeight);
  switch (performanceRating) {
    case WORST:
      //original formula commented out because we want the review to be the same as with new cards if the user got a learned card wrong
      //this needs to be flexible for future adaptions
      //interval = Math.round(word.interval * (1 / difficultyWeight / difficultyWeight)) || 1;
      interval = 2;
      break;

    case HARD:
      interval = (word.interval < 3) ? 3 : Math.round(word.interval *1.2 );
      break;

    default:
      interval = Math.round(parseFloat(word.interval * (1 + (difficultyWeight - 1) * percentOverDue)));
      //console.log(interval);
  }

    return {
    difficulty: difficulty,
    interval: interval,
    dueDate: today + interval,
    update: today,
    word: word.word
  };
};

//just for simulation
var TODAY = 1000000;

//just for simulation, this needs to be saved
var initialRecord = {
  interval: 1,
  dueDate: TODAY,
  update: TODAY - 1
};

var simulate = function simulate(difficulty, thrashHold, queue, scale) {
  var record = _extends({}, initialRecord, {
    difficulty: difficulty,
    dueDate: TODAY,
    update: TODAY - 1
  });

  var index = 1;
  var day = void 0;
  
  for (const el of queue) {
    /*if ((record.difficulty < thrashHold)) {
      console.info("-1,-1,-1,-1,-1");
    }
    else {*/
      day = record.dueDate - TODAY;
      record = calculate(record, el, record.dueDate, scale);
      console.info( day + "," + record.interval + "," + record.difficulty.toFixed(3) + "," + index + "," + scale);
    //}
    index += 1;    
  }
};

module.exports = {
  simulate: simulate,
  calculate: calculate,
  getPercentOverdue: getPercentOverdue,
  WORST: WORST,
  CORRECT: CORRECT,
  BEST: BEST,
  HARD: HARD
};