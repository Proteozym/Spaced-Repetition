"use strict";

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var WORST = 0.6;
var HARD = 0.8;
var CORRECT = 0.86;
var BEST = 1;

var limitNumber = function limitNumber(number, min, max) {
  var ret = number;
  if (number < min) {
    ret = min;
  } else if (number > max) {
    ret = max;
  }
  return ret;
};

// Value between 1 and 2
var getPercentOverdue = function getPercentOverdue(word, today) {
  var calculated = (today - word.update) / word.interval;
  return calculated > 2 ? 2 : calculated;
};

var getRandomFloat = function getRandomFloat(min, max) {
  return Math.random() * (max - min) + min;
}

var calculate = function calculate(word, performanceRating, today) {

  var percentOverDue = getPercentOverdue(word, today);

  //Value between 0 (Easy) and 1 (Difficult)
  var difficulty = limitNumber(word.difficulty + (7 - 9 * performanceRating) * percentOverDue / 17, 0, 1);
  var difficultyWeight = 3 - 1.7 * difficulty;

  var interval;

  switch (performanceRating) {
    case WORST:
      //original formula commented out because we want the review to be the same as with new cards if the user got a learned card wrong
      //this needs to be flexible for future adaptions
      //interval = Math.round(word.interval * (1 / difficultyWeight / difficultyWeight)) || 1;
      interval = 2;
      break;

    case HARD:
      interval = Math.round(word.interval * 1.2 * getRandomFloat(0.95, 1.05));
      break;

    default:
      interval = Math.round(parseFloat(word.interval * (1 + (difficultyWeight - 1) * percentOverDue) * getRandomFloat(0.95, 1.05)));
  }

  return {
    difficulty: difficulty,
    interval: interval,
    dueDate: today + interval,
    update: today,
    word: word.word
  };
};

//just for simulation
var TODAY = 1000000;

//just for simulation, this needs to be saved
var initialRecord = {
  interval: 1,
  dueDate: TODAY,
  update: TODAY - 1
};

var simulate = function simulate(difficulty, thrashHold, queue) {
  var record = _extends({}, initialRecord, {
    difficulty: difficulty,
    dueDate: TODAY,
    update: TODAY - 1
  });

  var index = 1;
  var day = void 0;
  console.info("day" + "," + "interval" + "," + "index" + "," + "performanceRating" + "," + "difficulty");
  for (const el of queue) {
    /*if ((record.difficulty < thrashHold)) {
      console.info("-1,-1,-1,-1,-1");
    }
    else {*/
      day = record.dueDate - TODAY;
      record = calculate(record, el, record.dueDate);
      console.info(day + "," + record.interval + "," + index + "," + el + "," + record.difficulty);
    //}
    index += 1;    
  }
};

module.exports = {
  simulate: simulate,
  calculate: calculate,
  getPercentOverdue: getPercentOverdue,
  WORST: WORST,
  CORRECT: CORRECT,
  BEST: BEST,
  HARD: HARD
};