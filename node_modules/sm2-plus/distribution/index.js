"use strict";

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var WORST = 0;
var CORRECT = 0.85;
var BEST = 1;

var limitNumber = function limitNumber(number, min, max) {
  var ret = number;
  if (number < min) {
    ret = min;
  } else if (number > max) {
    ret = max;
  }
  return ret;
};

var getPercentOverdue = function getPercentOverdue(word, today) {
  var calculated = (today - word.update) / word.interval;
  return calculated > 2 ? 2 : calculated;
};

var getRandomFloat = function getRandomFloat(min, max) {
  return Math.random() * (max - min) + min;
}

var calculate = function calculate(word, performanceRating, today) {
  var percentOverDue = getPercentOverdue(word, today);
  var difficulty = limitNumber(word.difficulty + (7 - 9 * performanceRating) * percentOverDue / 17, 0, 1);
  var difficultyWeight = 3 - 1.7 * difficulty;

    //TODO: 
    //Session handling
    //How to handle within sessions ordering?

  if (word.interval !=1)
  var interval;
  if (performanceRating === WORST) {

    //TODO: 
    //INCLUDE LAPSING (Wrong after Streak of Right) AND LEARNING HANDLING:

    //check if right
      //interval = Math.round(word.interval * (1 / difficultyWeight / difficultyWeight)) || 1;
      interval = 1;
      
  } else {
    interval = Math.round(parseFloat(word.interval * (1 + (difficultyWeight - 1) * percentOverDue) * getRandomFloat(0.95, 1.05)));
  }

  return {
    difficulty: difficulty,
    interval: interval,
    dueDate: today + interval,
    update: today,
    word: word.word
  };
};

var TODAY = 1000000;

//just for simulation, this needs to be saved
var initialRecord = {
  interval: 1,
  dueDate: TODAY,
  update: TODAY - 1
};

  var simulate = function simulate(difficulty, thrashHold, queue) {
    var record = _extends({}, initialRecord, {
      difficulty: difficulty,
      dueDate: TODAY,
      update: TODAY - 1
    });

    var index = 1;
    var day = void 0;
  
    for (const el of queue) {
      if ((record.difficulty < thrashHold)) return;
      day = record.dueDate - TODAY;
      record = calculate(record, el, record.dueDate);
      console.info(day + "," + record.interval + "," + index + "," + el + "," + record.difficulty);
      index += 1;
      
    }
  };

module.exports = {
  simulate: simulate,
  calculate: calculate,
  getPercentOverdue: getPercentOverdue,
  WORST: WORST,
  CORRECT: CORRECT,
  BEST: BEST
};